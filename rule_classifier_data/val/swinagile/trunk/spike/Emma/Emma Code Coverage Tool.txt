

EMMA CODE COVERAGE TOOL SPIKE PLAN

CVS Module/Location:

	http://adp-fulltimers.googlecode.com/svn/trunk/spike/

Overview:

	This spike seeks to examine the setup and configuration of the Emma code coverage tool.

Background/Context:

	This spike is being undertaken because: a) It is a project requirement, and b) because we will use Emma to analysis the test coverage of our project – this will minimise defects.

Goals/Risks:

	Ensure a high level of test case coverage for our project.
	Detect areas of functionality in our code that have not been tested.

Deliverables:

	The deliverables will be an example ant file suitable for inclusion in our build process and a description of how the Emma Ant Tasks are used to analyse our code base.
	These deliverables will be listed on our team's Wiki as well as being included under the spike folder on our SVN repository.

Resources:

	Andrew Cowan

Planned Start Date:

	4th October 2006

Deadline:

	18th October  2006

Current status:

	Completed

Analysis/Planning/Design Notes:

	As Emma has quite similar requirements to several other code coverage tools, I will not focus on describing design decisions, but will rather focus on describing the functionality in the final report.



SPIKE OUTCOMES

Goal/Risk:

	Ensure a high level of test case coverage for our project

	When first run we found that we only had a test code coverage of 6%  -  once this was identified, we could easily determine which areas of our project required additional testing and have now ramped it up to 27%.  Ideally we wish to maintain a minimum of 80% test case coverage.

	Detect areas of functionality in our code that have not been tested

	We found that we are not adequately testing our Chart Generation and Version Configuration code base.

Tasks undertaken:

	Read through the example ant build scripts provided with the Emma toolkit.
	Tuned the generation of Emma using an iterative approach – when I first tried to configure everything all at once, I could not determine the cause of failures I later received.

What we found out:

	Emma was relatively easy to install and integrate into our build process.  The only area of complication was the manner in which instrumented class files where generated.

	The ANT steps required are as follows:

	Define emma library file dependencies and Ant Task

	<path id="emma.lib" >
		<pathelement location="${dir.lib}/emma.jar" />
		<pathelement location="${dir.lib}/emma_ant.jar" />
	</path>
	<taskdef resource="emma_ant.properties" classpathref="emma.lib"/>

	Add an Ant property to the build.properties file to store new folder names

	dir.instr=${basedir}\\instr
	dir.coverage=${dir.doc}\\coverage

	Create an additional folder to hold instrumented class files and coverage reports

	<target name="prepare" depends="init">
		<mkdir dir="${dir.classes}"/>
		<mkdir dir="${dir.instr}"/>
		<mkdir dir="${dir.target}"/>
		<mkdir dir="${dir.javadoc}"/>
		<mkdir dir="${dir.coverage}"/>
		<mkdir dir="${dir.reports}"/>
		<mkdir dir="${dir.pmd}"/>
	</target>

	Update the Ant target 'clean' to remove instrumented class files and coverage reports

	<target name="clean" depends="init" description="clobbers files generated by the build process">
		<delete dir="${dir.classes}"/>
		<delete dir="${dir.instr}"/>
		<delete includeemptydirs="true">
			<fileset dir="${dir.reports}" includes="**/*"/>
		</delete>
		<delete includeemptydirs="true">
			<fileset dir="${dir.javadoc}" includes="**/*"/>
		</delete>
		<delete includeemptydirs="true">
			<fileset dir="${dir.coverage}" includes="**/*"/>
		</delete>
		<delete includeemptydirs="true">
			<fileset dir="${dir.pmd}" includes="**/*"/>
		</delete>
		<delete file="${dir.target}/${project.name}.jar"/>
		<delete file="${dir.target}/${project.name}.zip"/>
	</target>

	Create an Ant task to perform the Emma Code Coverage Analysis

	<target name="emma" depends="compile">
		<property name="emma.enabled" value="true"/>
		<property name="emma.filter" value=""/>
		<emma enabled="${emma.enabled}">
			<instr instrpath="${dir.classes}" destdir="${dir.instr}" metadatafile="${dir.coverage}/coverage.emma" mode="copy" merge="true">
				<filter value="${emma.filter}"/>
			</instr>
		</emma>
		<junit fork="true" haltonfailure="no">
			<jvmarg value="-Demma.coverage.out.file=${dir.coverage}/coverage.emma"/>
			<jvmarg value="-Demma.coverage.out.merge=true"/>
			<classpath>
				<pathelement path="${dir.instr}"/>
				<pathelement path="${classpath}"/>
				<path refid="emma.lib" />
			</classpath>
			<batchtest fork="yes" todir="${dir.reports}">
				<fileset dir="${dir.test}">
					<include name="**/*.java"/>
				</fileset>
			</batchtest>
		</junit>
		<emma enabled="${emma.enabled}">
			<report sourcepath="${dir.src}" sort="+block,+name,+method,+class" metrics="method:70,block:80,line:80,class:100">
				<fileset dir="${dir.coverage}">
					<include name="*.emma"/>
				</fileset>
				<txt outfile="${dir.coverage}/coverage.txt" depth="package" columns="class,method,block,line,name"/>
				<xml outfile="${dir.coverage}/coverage.xml" depth="package"/>
				<html outfile="${dir.coverage}/coverage.html" depth="method" columns="name,class,method,block,line"/>
			</report>
		</emma>
	</target>

	In more detail….

	The emma target <target name="emma" depends="compile"> is made to depend on the 'compile' target. This is because we need to ensure that we have class files for Emma to instrument.

	The two properties <property name="emma.enabled" value="true"/> and  <property name="emma.filter" value=""/> are used to configure emma.  The former property is the important one as it tells the Emma toolkit whether or not to perform code coverage analysis when the runtime actually runs the instrumented codebase.

	The next task defines the first step in the analysis process <emma enabled="${emma.enabled}"> - the enabled flag allows us to skip the task if desired.  The critical section is as follows:
	<instr instrpath="${dir.classes}" destdir="${dir.instr}" metadatafile="${dir.coverage}/coverage.emma" mode="copy" merge="true">
		<filter value="${emma.filter}"/>
	</instr>
	This step actually tells Emma to inject analysis code into the classes found on the instrpath and to place the now instrumented classes into the destdir location.  These instrumented classes are now ready to be used.

	To use them we need to make the java runtime execute code inside the instrumented classes.  As we wish to run an analysis of our Test Code Coverage, we will use our Test Cases to do this:
	<junit fork="true" haltonfailure="no">
		<jvmarg value="-Demma.coverage.out.file=${dir.coverage}/coverage.emma"/>
		<jvmarg value="-Demma.coverage.out.merge=true"/>
		<classpath>
			<pathelement path="${dir.instr}"/>
			<pathelement path="${classpath}"/>
			<path refid="emma.lib" />
		</classpath>
		<batchtest fork="yes" todir="${dir.reports}">
			<fileset dir="${dir.test}">
				<include name="**/*.java"/>
			</fileset>
		</batchtest>
	</junit>
	As you can see, this section is pretty much a straight Junit Ant task.  The only exceptions are the following points:  A) We need to ensure that the JVM used by Junit is forked as Emma requires the JVM to be initialised – something we cannot do while running Ant.  B) We need to pass some additional JVM arguments to the new JVM to let it know where our generated Emma coverage file data is located and that we want the coverage results to be merged into our coverage data.

	The final task more or less simply takes our coverage analysis data and generates some nicely formated reports from it:
	<emma enabled="${emma.enabled}">
		<report sourcepath="${dir.src}" sort="+block,+name,+method,+class" metrics="method:70,block:80,line:80,class:100">
			<fileset dir="${dir.coverage}">
				<include name="*.emma"/>
			</fileset>
			<txt outfile="${dir.coverage}/coverage.txt" depth="package" columns="class,method,block,line,name"/>
			<xml outfile="${dir.coverage}/coverage.xml" depth="package"/>
			<html outfile="${dir.coverage}/coverage.html" depth="method" columns="name,class,method,block,line"/>
		</report>
	</emma>
	As you can see, in this instance we have chosen to deliver the reports in HTML, XML and plain text format.


Open issues/risks:

	Emma code coverage is currently also including the analysis of our test case classes in the analysis.  One option is to perform a separate compile step, only including the main application classes, before instrumenting the classes and running the unit tests.  As the unit tests would need to refer to the instrumented classes, I am not sure if this will be possible.

Recommendations:

	Continue using the Emma analysis as configured – it is a relatively easy task to separate the unit tests from the main classes anyway.   One option to make this simple would be to move the unit tests into their own package, such as:  swin.metrictool.tests.
